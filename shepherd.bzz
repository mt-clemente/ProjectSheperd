include "vec2.bzz"

INTERACTION_RADIUS = 300
G = 10
CLOCK = 0
function random_walk() {
    
    if (proximity[1].value != 0 and proximity[1].value < 5 or proximity[0].value != 0 and proximity[0].value < 20) {
        gotop(0,math.pi)
    } else if (proximity[7].value != 0 and proximity[7].value < 5)  {
        gotop(0,math.pi)
    } else {
        gotop(20,0)
    }
}




function sum(rid, data, accum) {

    lvec = math.vec2.newp(data.distance, data.azimuth)
    return math.vec2.add(lvec, accum)
}

# Light Following Function
function neighbor_centroid(interacting) {
    var prox_vector = reduce(interacting, sum, math.vec2.new(0.0, 0.0))
	return math.vec2.sub(prox_vector,pose.position)
}


function cohesion() {
    var centroid = reduce(proximity, sum, math.vec2.new(0.0, 0.0))
    return centroid_vec
}

function angle_sum(rid, data, accum) {
    lvec = math.vec2.newp(20,data.pose.orientation.yaw)
    return math.vec2.add(lvec,accum)
}



# Executed at init time
function init() {

    x = pose.position.x
    y = pose.position.y
    
    align = math.vec2.new(0,0)
    i = 0
    neighbors.listen("yaw",
    function(vid,value,rid) {
        if (neighbors.get(rid).distance < INTERACTION_RADIUS) {
            i = i + 1
            var vec = math.vec2.newp(1,value)
            align = math.vec2.add(align,vec)
        }
    }
    )
    
}


# Executed every time step
function step() {
    
    debug.print("NE ",neighbors.count())
    # log(i)
    i = 0
    CLOCK = CLOCK + 1
    
    neighbors.broadcast("yaw", pose.orientation.yaw)
    
    
    var interacting = neighbors.filter(function(rid, data) {
        # We assume the distance is expressed in centimeters
        return data.distance < INTERACTION_RADIUS
    }
    )

    var force = math.vec2.new(0.0,0.0)

        
    var centroid = neighbor_centroid(interacting.poses)
    var sep = math.vec2.scale(centroid,-0.6)
    var coh = math.vec2.scale(centroid, 1/ (interacting.count()+ 0.1))
    force = math.vec2.add(sep,coh)
         
    align = math.vec2.add(align,math.vec2.newp(1,pose.orientation.yaw))    
    align = math.vec2.scale(align,800 / math.vec2.length(align))
    
    alpha = math.vec2.angle(align)
    align_var = align
    align_relat = math.vec2.rotate(align,-pose.orientation.yaw)
    
    # debug.print(align.x," | ",align.y)
    force = math.vec2.new(0,0)
    force = math.vec2.add(force,align_relat)
    force = math.vec2.scale(force, 70 / math.vec2.length(force))
    forward = math.vec2.new(10,0)
    
    speed = math.vec2.new(pose.position.x -x,pose.position.y -y)
    speed = math.vec2.scale(speed, 20/ (math.vec2.length(speed)+0.01))

    v = math.vec2.add(force,speed)
    v = math.vec2.add(forward,v)
    
    goto(v.x,v.y)
    
    x = pose.position.x
    y = pose.position.y
    align = math.vec2.new(0,0)
}

function reset(){
}

# Execute at exit
function destroy() {
}

