include "vec2.bzz"

INTERACTION_RADIUS = 400
WALL_INFLUENCE_DURATION = 200
COHERENCE_COEFF = 5
SEPARATION_COEFF = 1
ALIGNMENT_COEFF = 20000
# Without smoothing the behavior can be erratic or fall into patterns
# where the whole swarm oscilattes, smoothing by adding some velocity
# 'inertia' helps avoid that and give a more real feel to the movements.
#  Here is what v = v / smoothing + flock_forces
SMOOTHING = 10


CLOCK = 0


# Lennard-Jones parameters
TARGET     = 150.0
EPSILON    = 700.0

# Lennard-Jones interaction magnitude
function lj_magnitude(dist, target, epsilon) {
    return -(epsilon / dist) * ((target / dist)^4 - (target / dist)^2)
}
    
function sum(rid, data, accum) {

    lvec = math.vec2.newp(data.distance, data.azimuth)
    return math.vec2.add(lvec, accum)
}

# Light Following Function
function neighbor_centroid(interacting) {
    var prox_vector = reduce(interacting, sum, math.vec2.new(0.0, 0.0))
	return math.vec2.sub(prox_vector,pose.position)
}


function cohesion() {
    var centroid = reduce(proximity, sum, math.vec2.new(0.0, 0.0))
    return centroid_vec
}

function angle_sum(rid, data, accum) {
    lvec = math.vec2.newp(20,data.pose.orientation.yaw)
    return math.vec2.add(lvec,accum)
}





# Executed at init time
function init() {
		sheep = swarm.create(1)
		sheperd = swarm.create(2)

		if ( id == 0 or id == 1 or id == 2 or id == 3) {
				sheperd.join()
		}
		else{
				sheep.join()
		}

    x = pose.position.x
    y = pose.position.y
    wall = 6.0
    align = math.vec2.new(0,0)
		repulsion= math.vec2.new(0,0)
    i = 0
    recent_wall = 0
    neighb_walls = {}
    neighb_walls[id] = 8

    
    neighbors.listen("wall",
    function(vid,value,rid) {
        neighb_walls[rid] = value
    }
    )

		neighbors.listen("bark",
		function(vid,value,rid) {
			if (neighbors.get(rid).distance < INTERACTION_RADIUS) {
				var ecart=math.vec2.sub(pose.position,value)
				var l = math.vec2.length(ecart)
				ecart=math.vec2.norm(ecart)
				ecart=math.vec2.scale(ecart,lj_magnitude(l, TARGET, EPSILON))
				repulsion=math.vec2.add(repulsion,ecart)

			
			}
		
		}
		)

    
    neighbors.listen("yaw",
    function(vid,value,rid) {

            if  (isnil(neighb_walls[rid])) {
                w = 0
            } else {
                w = neighb_walls[rid]
            }
            if (neighbors.get(rid).distance < INTERACTION_RADIUS) {
                i = i + 1
                var vec = math.vec2.newp(w * 5 + 1,value)
                align = math.vec2.add(align,vec)
            }
        }
    )
}



# Executed every time step
function step() {
    
    CLOCK = CLOCK + 1
    neighbors.broadcast("yaw", pose.orientation.yaw)
    
    if (recent_wall > 0) {
        wall = 1
    } else {
        wall = 0
    }

    
    if (proximity[2].value != 0  and proximity[1].value < 5
        or proximity[1].value != 0 and proximity[1].value < 5
        or proximity[0].value != 0 and proximity[0].value < 5) {
        
            recent_wall = WALL_INFLUENCE_DURATION
            gotop(5,-math.pi/4)
            
        } else if (proximity[7].value != 0 and proximity[7].value < 5
        or proximity[6].value != 0 and proximity[6].value < 5)  {
            recent_wall = WALL_INFLUENCE_DURATION
            gotop(5,math.pi/4)
            
        } else {
            recent_wall = recent_wall - 1
						
						goto(0,0)

        		if (sheep.in()) {
						flocking(
            ALIGNMENT_COEFF,
            SEPARATION_COEFF,
            COHERENCE_COEFF,
            SMOOTHING
            )
						}

						if (sheperd.in()){
						neighbors.broadcast("bark", pose.position)
						}
						
            
        }
    neighbors.broadcast("wall", wall)
        
    x = pose.position.x
    y = pose.position.y
    align = math.vec2.new(0,0)
		repulsion= math.vec2.new(0,0)
}


# Working base weights are
# Alignment coeff:          ali = 8000
# Separation coeff:         sep = 0.6
# Cohesion coeff:           coh = 1
# Degree of independece:    indep = 1

function flocking(ali, sep, coh, smoothing) {
		
		debug.print(repulsion.x,"|",repulsion.y)

    var interacting = neighbors.filter(function(rid, data) {
        # We assume the distance is expressed in centimeters
        return data.distance < INTERACTION_RADIUS
    }
    )

    var force = math.vec2.new(0.0,0.0)
    
            
    var centroid = neighbor_centroid(interacting.poses)
    var sep_v = math.vec2.scale(centroid,-sep)
    var coh_v = math.vec2.scale(centroid, coh/ (interacting.count()+ 0.1))
    force = math.vec2.add(sep_v,coh_v)
        
    align = math.vec2.add(align,math.vec2.newp(1,pose.orientation.yaw))    
    align = math.vec2.scale(align,ali / math.vec2.length(align))
    
    alpha = math.vec2.angle(align)
    align_var = align
    align_relat = math.vec2.rotate(align,-pose.orientation.yaw)
    
    # debug.print(align.x," | ",align.y)
    force = math.vec2.add(force,align_relat)
    force = math.vec2.scale(force, 100 / math.vec2.length(force))
    forward = math.vec2.new(0,0)
    
    speed = math.vec2.new(pose.position.x -x,pose.position.y -y)
    speed = math.vec2.scale(speed,  100/ (smoothing * (math.vec2.length(speed)+0.01)))

    v = math.vec2.add(force,speed)
    v = math.vec2.add(forward,v)
		
    
    goto(v.x,v.y)
}

function reset(){
}

# Execute at exit
function destroy() {
}

